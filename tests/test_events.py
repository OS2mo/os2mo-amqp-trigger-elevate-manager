# SPDX-FileCopyrightText: 2022 Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import unittest.mock
from unittest.mock import AsyncMock
from uuid import uuid4

import pytest

from elevate_manager.autogenerated_graphql_client.get_manager_engagement import (
    GetManagerEngagementManagersObjectsCurrentEmployeeEngagements,
)
from elevate_manager.events import process_manager_event


@pytest.mark.asyncio
@unittest.mock.patch("elevate_manager.events.get_manager_engagements")
@unittest.mock.patch("elevate_manager.events.logger")
async def test_process_manager_event_none_when_no_engagements_found_in_manager_obj(
    mock_events_logger, mock_get_managers_function
):
    """
    Tests if:
    1) process_manager_event returns None when no engagement found in
       manager object.
    2) logging message gets properly logged with correct error level.
    """
    # ARRANGE
    manager_uuid = uuid4()
    mocked_gql_client = AsyncMock()
    mock_get_managers_function.side_effect = ValueError()

    # ACT
    result = await process_manager_event(
        gql_client=mocked_gql_client,
        manager_uuid=manager_uuid,
    )

    # ASSERT
    assert result is None
    mock_events_logger.error.assert_any_call(
        "No employee was found in the manager object"
    )


@pytest.mark.asyncio
@unittest.mock.patch("elevate_manager.events.get_manager_engagements")
@unittest.mock.patch("elevate_manager.events.logger")
async def test_process_manager_event_none_when_no_manager_obj_found(
    mock_events_logger, mock_get_managers_function
):
    """
    Tests if:
    1) process_manager_event returns None when no manager object found.
    2) logging message gets properly logged with correct error level.
    """

    # ARRANGE
    manager_no_objects: dict = {"managers": {"objects": []}}

    mock_get_managers_function.return_value = manager_no_objects

    # ACT
    result = await process_manager_event(
        gql_client=AsyncMock(),
        manager_uuid=uuid4(),
    )

    # ASSERT
    assert result is None
    mock_events_logger.error.assert_any_call("No manager objects found")


@pytest.mark.asyncio
@pytest.mark.parametrize(
    "engagements",
    [
        [],
        [
            GetManagerEngagementManagersObjectsCurrentEmployeeEngagements(
                uuid=str(uuid4())
            ),
            GetManagerEngagementManagersObjectsCurrentEmployeeEngagements(
                uuid=str(uuid4())
            ),
        ],
    ],
)
@unittest.mock.patch("elevate_manager.events.get_manager_engagements")
@unittest.mock.patch("elevate_manager.events.logger")
async def test_process_manager_event_none_when_manager_does_not_have_one_engagement(
    mock_events_logger, mock_get_managers_function, engagements
):
    """
    Tests if:
    1) process_manager_event returns None when manager does not have exactly
       one engagement.
    2) logging message gets properly logged with correct error level.
    """
    manager_no_engagements: dict = {
        "managers": {
            "objects": [
                {
                    "current": {
                        "employee": [{"engagements": engagements}],
                        "org_unit_uuid": str(uuid4()),
                    }
                }
            ]
        }
    }
    mock_get_managers_function.return_value = manager_no_engagements

    # ACT
    result = await process_manager_event(
        gql_client=AsyncMock(),
        manager_uuid=uuid4(),
    )

    # ASSERT
    assert result is None
    mock_events_logger.error.assert_any_call(
        "Manager does not have exactly one engagement, and engagement can not be moved"
    )


@unittest.mock.patch("elevate_manager.events.terminate_existing_managers")
@unittest.mock.patch("elevate_manager.events.get_existing_managers")
@unittest.mock.patch("elevate_manager.events.get_manager_engagements")
async def test_terminate_managers_when_existing_managers_present(
    mock_get_manager_engagements: AsyncMock,
    mock_get_existing_managers: AsyncMock,
    mock_terminate_existing_managers: AsyncMock,
):
    """Test that any existing managers are terminated"""

    # ARRANGE
    org_unit_uuid = uuid4()

    graphql_manager_engagements = {
        "managers": {
            "objects": [
                {
                    "current": {
                        "employee": [{"engagements": [{"uuid": str(uuid4())}]}],
                        "org_unit_uuid": str(org_unit_uuid),
                    }
                }
            ]
        }
    }
    mock_get_manager_engagements.return_value = graphql_manager_engagements

    graphql_existing_managers_resp = {
        "org_units": {
            "objects": [
                {
                    "current": {
                        "managers": [
                            {"uuid": str(uuid4()), "user_key": "some manager 1"},
                            {"uuid": str(uuid4()), "user_key": "some manager 2"},
                        ]
                    }
                }
            ]
        }
    }

    mock_get_existing_managers.return_value = graphql_existing_managers_resp

    gql_client = AsyncMock()
    manager_uuid = uuid4()

    # ACT
    await process_manager_event(
        gql_client=gql_client,
        manager_uuid=manager_uuid,
    )

    # ASSERT
    mock_get_existing_managers.assert_awaited_once_with(org_unit_uuid, gql_client)
    mock_terminate_existing_managers.assert_awaited_once_with(
        gql_client, graphql_existing_managers_resp, manager_uuid
    )


@unittest.mock.patch("elevate_manager.events.move_engagement")
@unittest.mock.patch("elevate_manager.events.get_existing_managers")
@unittest.mock.patch("elevate_manager.events.get_manager_engagements")
async def test_move_engagement(
    mock_get_manager_engagements: AsyncMock,
    mock_get_existing_managers: AsyncMock,
    mock_move_engagement: AsyncMock,
):
    """Test that the new manager is moved"""

    # ARRANGE
    engagement_uuid = uuid4()
    manager_uuid = uuid4()
    manager_ou_uuid = uuid4()

    # HERE
    graphql_manager_engagements = {
        "managers": {
            "objects": [
                {
                    "current": {
                        "employee": [{"engagements": [{"uuid": str(engagement_uuid)}]}],
                        "org_unit_uuid": str(manager_ou_uuid),
                    }
                }
            ]
        }
    }
    mock_get_manager_engagements.return_value = graphql_manager_engagements

    graphql_existing_managers_resp: dict = {
        "org_units": {"objects": [{"current": {"managers": []}}]}
    }
    mock_get_existing_managers.return_value = graphql_existing_managers_resp

    gql_client = AsyncMock()

    # ACT
    await process_manager_event(
        gql_client=gql_client,
        manager_uuid=manager_uuid,
    )

    # ASSERT
    mock_move_engagement.assert_awaited_once_with(
        gql_client, manager_ou_uuid, engagement_uuid
    )
